{% extends "base.html" %}

{% block title %}RAGpy - Data Processing Pipeline{% endblock %}

{% block extra_css %}
<style>
  /* Pipeline-specific styles */
  .pipeline-page {
    padding: var(--space-6);
    max-width: 1200px;
    margin: 0 auto;
  }

  .pipeline-header {
    text-align: center;
    margin-bottom: var(--space-8);
  }

  .pipeline-header h1 {
    font-size: var(--text-3xl);
    font-weight: var(--font-bold);
    color: var(--color-text-primary);
    margin-bottom: var(--space-2);
  }

  .pipeline-header p {
    color: var(--color-text-secondary);
    font-size: var(--text-base);
  }

  /* Project Banner */
  .project-banner {
    background: linear-gradient(135deg, var(--color-brand-primary) 0%, #2563EB 100%);
    color: white;
    padding: var(--space-4) var(--space-6);
    border-radius: var(--radius-lg);
    margin-bottom: var(--space-6);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .project-banner-info {
    display: flex;
    align-items: center;
    gap: var(--space-4);
  }

  .project-banner-name {
    font-weight: var(--font-semibold);
    font-size: var(--text-lg);
  }

  .project-banner-session {
    opacity: 0.85;
    font-size: var(--text-sm);
  }

  .project-banner-back {
    background: rgba(255,255,255,0.2);
    color: white;
    padding: var(--space-2) var(--space-4);
    border-radius: var(--radius-md);
    text-decoration: none;
    font-size: var(--text-sm);
    transition: background var(--transition-fast);
  }

  .project-banner-back:hover {
    background: rgba(255,255,255,0.3);
    color: white;
  }

  /* Step Tracker */
  .step-tracker {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: var(--space-8);
    padding: var(--space-6);
    background: var(--color-surface);
    border-radius: var(--radius-xl);
    border: 1px solid var(--color-border);
  }

  .step-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-2);
    position: relative;
    min-width: 100px;
    opacity: 0.5;
    transition: all var(--transition-base);
  }

  .step-item.active,
  .step-item.completed {
    opacity: 1;
  }

  .step-number {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--color-bg-tertiary);
    color: var(--color-text-tertiary);
    border-radius: 50%;
    font-weight: var(--font-semibold);
    font-size: var(--text-base);
    border: 2px solid var(--color-border);
    transition: all var(--transition-base);
  }

  .step-item.active .step-number {
    background: var(--color-brand-primary-light);
    color: var(--color-brand-primary);
    border-color: var(--color-brand-primary);
  }

  .step-item.completed .step-number {
    background: var(--color-success);
    color: white;
    border-color: var(--color-success);
  }

  .step-title {
    font-size: var(--text-sm);
    font-weight: var(--font-medium);
    color: var(--color-text-secondary);
  }

  .step-item.active .step-title,
  .step-item.completed .step-title {
    color: var(--color-text-primary);
  }

  .step-connector {
    width: 60px;
    height: 2px;
    background: var(--color-border);
    margin: 0 var(--space-2);
    transition: background var(--transition-base);
  }

  .step-connector.completed {
    background: var(--color-success);
  }

  .step-file-link {
    font-size: var(--text-xs);
    color: var(--color-brand-primary);
    text-decoration: none;
    margin-top: var(--space-1);
  }

  /* Global Controls */
  .global-controls {
    text-align: center;
    margin-bottom: var(--space-6);
  }

  /* Pipeline Sections */
  .pipeline-section {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-xl);
    margin-bottom: var(--space-6);
    overflow: hidden;
    transition: all var(--transition-base);
  }

  .pipeline-section.step-locked {
    opacity: 0.5;
    pointer-events: none;
  }

  .pipeline-section.step-completed {
    border-color: var(--color-success);
  }

  .section-header {
    padding: var(--space-5) var(--space-6);
    border-bottom: 1px solid var(--color-border);
    display: flex;
    align-items: center;
    gap: var(--space-4);
  }

  .section-number {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--color-brand-primary-light);
    color: var(--color-brand-primary);
    border-radius: 50%;
    font-weight: var(--font-semibold);
    flex-shrink: 0;
  }

  .pipeline-section.step-completed .section-number {
    background: var(--color-success);
    color: white;
  }

  .section-header h2 {
    font-size: var(--text-lg);
    font-weight: var(--font-semibold);
    margin: 0;
    flex: 1;
  }

  .section-body {
    padding: var(--space-6);
  }

  /* Upload Options */
  .upload-options {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-4);
  }

  @media (max-width: 768px) {
    .upload-options {
      grid-template-columns: 1fr;
    }
  }

  .upload-option {
    border: 2px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-5);
    transition: all var(--transition-base);
  }

  .upload-option:hover {
    border-color: var(--color-brand-primary);
    box-shadow: var(--shadow-md);
  }

  .upload-option.option-zip {
    border-color: var(--color-brand-primary);
    background: var(--color-brand-primary-light);
  }

  .upload-option.option-csv {
    border-color: var(--color-success);
    background: var(--color-success-light);
  }

  .upload-option-header {
    display: flex;
    align-items: center;
    gap: var(--space-3);
    margin-bottom: var(--space-3);
  }

  .upload-option-icon {
    font-size: 1.5rem;
  }

  .upload-option-title {
    font-size: var(--text-base);
    font-weight: var(--font-semibold);
    color: var(--color-text-primary);
  }

  .upload-option.option-zip .upload-option-title {
    color: var(--color-brand-primary);
  }

  .upload-option.option-csv .upload-option-title {
    color: var(--color-success-dark);
  }

  .upload-option-desc {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
    margin-bottom: var(--space-4);
  }

  .upload-form {
    display: flex;
    gap: var(--space-3);
    align-items: center;
  }

  .upload-form input[type="file"] {
    flex: 1;
    padding: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
  }

  /* Decision Tree */
  .decision-tree {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-xl);
    margin-bottom: var(--space-6);
    overflow: hidden;
  }

  .decision-tree.step-locked {
    opacity: 0.5;
    pointer-events: none;
  }

  .decision-tree-header {
    padding: var(--space-5) var(--space-6);
    border-bottom: 1px solid var(--color-border);
    text-align: center;
  }

  .decision-tree-header h2 {
    font-size: var(--text-xl);
    font-weight: var(--font-semibold);
    margin: 0 0 var(--space-2);
  }

  .tree-subtitle {
    color: var(--color-text-secondary);
    font-size: var(--text-sm);
    margin: 0;
  }

  .branches-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-6);
    padding: var(--space-6);
  }

  @media (max-width: 1024px) {
    .branches-container {
      grid-template-columns: 1fr;
    }
  }

  .branch {
    border: 2px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
    opacity: 0.6;
    transition: all var(--transition-base);
  }

  .branch.selected {
    opacity: 1;
    box-shadow: var(--shadow-md);
  }

  .branch-rag.selected {
    border-color: var(--color-brand-primary);
  }

  .branch-zotero.selected {
    border-color: #8B5CF6;
  }

  .branch-header {
    padding: var(--space-4);
    background: var(--color-bg-tertiary);
    display: flex;
    align-items: center;
    gap: var(--space-3);
  }

  .branch-header input[type="radio"] {
    width: 20px;
    height: 20px;
    accent-color: var(--color-brand-primary);
  }

  .branch-header label {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    cursor: pointer;
    flex: 1;
  }

  .branch-icon {
    font-size: 1.25rem;
  }

  .branch-title {
    font-weight: var(--font-semibold);
    font-size: var(--text-base);
  }

  .branch-content {
    padding: var(--space-5);
  }

  /* Sub-sections within branches */
  .sub-section {
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-lg);
    padding: var(--space-5);
    margin-bottom: var(--space-4);
    transition: all var(--transition-base);
  }

  .sub-section:last-child {
    margin-bottom: 0;
  }

  .sub-section.step-locked {
    opacity: 0.5;
    pointer-events: none;
  }

  .sub-section.step-completed {
    background: var(--color-success-light);
  }

  .sub-section h3 {
    font-size: var(--text-base);
    font-weight: var(--font-semibold);
    margin: 0 0 var(--space-3);
  }

  .sub-section-warning {
    font-size: var(--text-sm);
    color: var(--color-warning-dark);
    background: var(--color-warning-light);
    padding: var(--space-3);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-4);
  }

  /* Stage Upload Form */
  .stage-upload-form {
    display: flex;
    gap: var(--space-3);
    align-items: center;
    margin-bottom: var(--space-4);
    padding: var(--space-3);
    background: var(--color-surface);
    border-radius: var(--radius-md);
    border: 1px dashed var(--color-border);
  }

  .stage-upload-form input[type="file"] {
    flex: 1;
    font-size: var(--text-sm);
  }

  .stage-upload-form button {
    flex-shrink: 0;
  }

  /* Model Input */
  .model-input-group {
    margin-bottom: var(--space-4);
  }

  .model-input-group label {
    display: block;
    font-size: var(--text-sm);
    font-weight: var(--font-medium);
    margin-bottom: var(--space-2);
  }

  .model-input-group input {
    width: 100%;
    max-width: 400px;
    padding: var(--space-2) var(--space-3);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
  }

  .model-input-hint {
    font-size: var(--text-xs);
    color: var(--color-text-tertiary);
    margin-top: var(--space-1);
  }

  /* Vector DB Options */
  .db-options {
    margin-top: var(--space-4);
  }

  .db-select-group {
    margin-bottom: var(--space-4);
  }

  .db-select-group select {
    width: 100%;
    max-width: 300px;
    padding: var(--space-2) var(--space-3);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
    background: var(--color-surface);
  }

  .db-params {
    display: grid;
    gap: var(--space-3);
    padding: var(--space-4);
    background: var(--color-surface);
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    margin-bottom: var(--space-4);
  }

  .db-params label {
    font-size: var(--text-sm);
    font-weight: var(--font-medium);
    margin-bottom: var(--space-1);
    display: block;
  }

  .db-params input {
    width: 100%;
    padding: var(--space-2) var(--space-3);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
  }

  /* Progress Bar */
  .progress-container {
    margin-top: var(--space-4);
    padding: var(--space-4);
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-lg);
  }

  .progress-header {
    display: flex;
    align-items: center;
    gap: var(--space-3);
    margin-bottom: var(--space-3);
  }

  .progress-count {
    font-weight: var(--font-semibold);
    min-width: 60px;
  }

  .progress-status {
    color: var(--color-text-secondary);
    font-size: var(--text-sm);
    flex: 1;
  }

  .progress-bar-wrapper {
    height: 8px;
    background: var(--color-border);
    border-radius: var(--radius-full);
    overflow: hidden;
  }

  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-brand-primary), var(--color-brand-primary-hover));
    border-radius: var(--radius-full);
    transition: width 0.3s ease;
    width: 0%;
  }

  .progress-bar-fill.zotero {
    background: linear-gradient(90deg, #8B5CF6, #A78BFA);
  }

  /* Secondary Progress Bar (for chunk-level progress) */
  .progress-secondary {
    margin-top: var(--space-3);
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .progress-secondary.active {
    opacity: 1;
    max-height: 100px;
  }

  .progress-secondary .progress-header {
    margin-bottom: var(--space-2);
  }

  .progress-secondary .progress-count {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
    min-width: 50px;
  }

  .progress-secondary .progress-status {
    font-size: var(--text-xs);
  }

  .progress-secondary .progress-bar-wrapper {
    height: 4px;
  }

  .progress-secondary .progress-bar-fill {
    background: linear-gradient(90deg, #10B981, #34D399);
  }

  .progress-label {
    font-size: var(--text-xs);
    font-weight: var(--font-medium);
    color: var(--color-text-tertiary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-1);
  }

  /* Multi-Item Progress (N mini-bars) */
  .multi-progress-container {
    margin-top: var(--space-3);
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
    max-height: 300px;
    overflow-y: auto;
  }

  .mini-progress-item {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-2);
    background: var(--color-bg-secondary);
    border-radius: var(--radius-md);
    border-left: 3px solid var(--color-brand-primary);
    transition: all 0.3s ease;
    animation: slideIn 0.3s ease;
  }

  @keyframes slideIn {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .mini-progress-item.completed {
    border-left-color: var(--color-success);
    opacity: 0.7;
  }

  .mini-progress-item.error {
    border-left-color: var(--color-error);
  }

  .mini-progress-item.skipped {
    border-left-color: var(--color-warning);
    opacity: 0.6;
  }

  .mini-progress-item.exists {
    border-left-color: var(--color-brand-primary);
    opacity: 0.7;
  }

  .mini-progress-icon {
    font-size: 1.2em;
    min-width: 24px;
    text-align: center;
  }

  .mini-progress-info {
    flex: 1;
    min-width: 0;
  }

  .mini-progress-title {
    font-size: var(--text-sm);
    font-weight: var(--font-medium);
    color: var(--color-text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .mini-progress-bar-wrapper {
    height: 4px;
    background: var(--color-border);
    border-radius: var(--radius-full);
    overflow: hidden;
    margin-top: 4px;
  }

  .mini-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #8B5CF6, #A78BFA);
    border-radius: var(--radius-full);
    transition: width 0.3s ease;
    width: 0%;
  }

  .mini-progress-bar.processing {
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  .mini-progress-status {
    font-size: var(--text-xs);
    color: var(--color-text-tertiary);
    min-width: 60px;
    text-align: right;
  }

  /* Result Box */
  .result {
    margin-top: var(--space-4);
    padding: var(--space-4);
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-lg);
    font-size: var(--text-sm);
  }

  .result:empty {
    display: none;
  }

  .result a {
    color: var(--color-brand-primary);
    font-weight: var(--font-medium);
  }

  .result .error-text {
    color: var(--color-error);
  }

  /* Zotero Options */
  .zotero-options {
    margin-bottom: var(--space-4);
  }

  .zotero-checkbox-group {
    display: flex;
    align-items: flex-start;
    gap: var(--space-2);
    padding: var(--space-3);
    background: var(--color-surface);
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    margin-bottom: var(--space-3);
  }

  .zotero-checkbox-group input[type="checkbox"] {
    width: 18px;
    height: 18px;
    margin-top: 2px;
  }

  .zotero-checkbox-label {
    flex: 1;
  }

  .zotero-checkbox-label strong {
    display: block;
    margin-bottom: var(--space-1);
  }

  .zotero-checkbox-label small {
    font-size: var(--text-xs);
    color: var(--color-text-tertiary);
    line-height: 1.4;
  }

  /* Animations */
  .fade-in {
    animation: fadeInUp 0.3s ease-out;
  }

  /* Settings Button */
  #settingsBtn {
    position: fixed;
    top: calc(var(--topbar-height) + var(--space-4));
    right: var(--space-4);
    width: 48px;
    height: 48px;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--color-brand-primary);
    font-size: 1.5rem;
    box-shadow: var(--shadow-md);
    z-index: 100;
    transition: all var(--transition-fast);
  }

  #settingsBtn:hover {
    transform: scale(1.05);
    box-shadow: var(--shadow-lg);
  }

  /* Danger Button */
  .danger-btn {
    background: var(--color-error);
    color: white;
    border: none;
    padding: var(--space-2) var(--space-4);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
    font-weight: var(--font-medium);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .danger-btn:hover {
    background: var(--color-error-dark);
  }
</style>
{% endblock %}

{% block content %}
<!-- Settings Button -->
<button id="settingsBtn" onclick="openModal('settingsModal')" title="Settings">
  <i class="bi bi-gear"></i>
</button>

<!-- Settings Modal -->
<div class="modal modal-lg" id="settingsModal">
  <div class="modal-header">
    <h3 class="modal-title">API Credentials</h3>
    <button class="modal-close" onclick="closeModal('settingsModal')">
      <i class="bi bi-x-lg"></i>
    </button>
  </div>
  <div class="modal-body">
    <form id="settingsForm">
      <!-- OpenAI -->
      <div class="card mb-4">
        <div class="card-body">
          <h4 class="text-brand mb-3"><i class="bi bi-robot"></i> OpenAI</h4>
          <div class="form-group mb-0">
            <label class="form-label" for="openaiKey">API Key</label>
            <input type="text" class="form-input" id="openaiKey" name="OPENAI_API_KEY" autocomplete="off" placeholder="sk-...">
          </div>
        </div>
      </div>

      <!-- OpenRouter -->
      <div class="card mb-4">
        <div class="card-body">
          <h4 class="text-brand mb-3"><i class="bi bi-arrow-left-right"></i> OpenRouter <span class="badge badge-neutral">Optional</span></h4>
          <div class="form-group">
            <label class="form-label" for="openrouterKey">API Key</label>
            <input type="text" class="form-input" id="openrouterKey" name="OPENROUTER_API_KEY" autocomplete="off" placeholder="sk-or-v1-...">
          </div>
          <div class="form-group mb-0">
            <label class="form-label" for="openrouterModel">Default Model</label>
            <input type="text" class="form-input" id="openrouterModel" name="OPENROUTER_DEFAULT_MODEL" autocomplete="off" placeholder="google/gemini-2.5-flash">
          </div>
        </div>
      </div>

      <!-- Mistral -->
      <div class="card mb-4">
        <div class="card-body">
          <h4 class="text-brand mb-3"><i class="bi bi-file-earmark-pdf"></i> Mistral <span class="badge badge-neutral">OCR</span></h4>
          <div class="form-group">
            <label class="form-label" for="mistralKey">API Key</label>
            <input type="text" class="form-input" id="mistralKey" name="MISTRAL_API_KEY" autocomplete="off" placeholder="Mistral API Key">
          </div>
          <div class="form-group">
            <label class="form-label" for="mistralModel">OCR Model</label>
            <input type="text" class="form-input" id="mistralModel" name="MISTRAL_OCR_MODEL" autocomplete="off" placeholder="mistral-ocr-latest">
          </div>
          <div class="form-group mb-0">
            <label class="form-label" for="mistralUrl">API Base URL</label>
            <input type="text" class="form-input" id="mistralUrl" name="MISTRAL_API_BASE_URL" autocomplete="off" placeholder="https://api.mistral.ai">
          </div>
        </div>
      </div>

      <!-- Pinecone -->
      <div class="card mb-4">
        <div class="card-body">
          <h4 class="text-brand mb-3"><i class="bi bi-database"></i> Pinecone</h4>
          <div class="form-group">
            <label class="form-label" for="pineconeKey">API Key</label>
            <input type="text" class="form-input" id="pineconeKey" name="PINECONE_API_KEY" autocomplete="off" placeholder="Pinecone API Key">
          </div>
          <div class="form-group mb-0">
            <label class="form-label" for="pineconeEnv">Environment</label>
            <input type="text" class="form-input" id="pineconeEnv" name="PINECONE_ENV" autocomplete="off" placeholder="Pinecone Environment">
          </div>
        </div>
      </div>

      <!-- Weaviate -->
      <div class="card mb-4">
        <div class="card-body">
          <h4 class="text-brand mb-3"><i class="bi bi-hdd-network"></i> Weaviate</h4>
          <div class="form-group">
            <label class="form-label" for="weaviateKey">API Key</label>
            <input type="text" class="form-input" id="weaviateKey" name="WEAVIATE_API_KEY" autocomplete="off" placeholder="Weaviate API Key">
          </div>
          <div class="form-group mb-0">
            <label class="form-label" for="weaviateUrl">URL</label>
            <input type="text" class="form-input" id="weaviateUrl" name="WEAVIATE_URL" autocomplete="off" placeholder="https://...">
          </div>
        </div>
      </div>

      <!-- Qdrant -->
      <div class="card mb-4">
        <div class="card-body">
          <h4 class="text-brand mb-3"><i class="bi bi-grid-3x3"></i> Qdrant</h4>
          <div class="form-group">
            <label class="form-label" for="qdrantKey">API Key</label>
            <input type="text" class="form-input" id="qdrantKey" name="QDRANT_API_KEY" autocomplete="off" placeholder="Qdrant API Key">
          </div>
          <div class="form-group mb-0">
            <label class="form-label" for="qdrantUrl">URL</label>
            <input type="text" class="form-input" id="qdrantUrl" name="QDRANT_URL" autocomplete="off" placeholder="http://...">
          </div>
        </div>
      </div>

      <!-- Zotero -->
      <div class="card" style="border-color: #8B5CF6;">
        <div class="card-body">
          <h4 style="color: #8B5CF6;" class="mb-3"><i class="bi bi-journal-bookmark"></i> Zotero <span class="badge badge-neutral">Optional</span></h4>
          <div class="form-group">
            <label class="form-label" for="zoteroApiKey">API Key</label>
            <input type="password" class="form-input" id="zoteroApiKey" name="ZOTERO_API_KEY" autocomplete="off" placeholder="Get from zotero.org/settings/keys/new">
          </div>
          <div class="form-group">
            <label class="form-label" for="zoteroUserId">User ID <span class="form-label-optional">(auto-detected)</span></label>
            <input type="text" class="form-input" id="zoteroUserId" name="ZOTERO_USER_ID" autocomplete="off" placeholder="Auto-detected from Zotero export">
          </div>
          <div class="form-group mb-0">
            <label class="form-label" for="zoteroGroupId">Group ID <span class="form-label-optional">(optional)</span></label>
            <input type="text" class="form-input" id="zoteroGroupId" name="ZOTERO_GROUP_ID" autocomplete="off" placeholder="For group libraries">
          </div>
        </div>
      </div>
    </form>
  </div>
  <div class="modal-footer">
    <div id="settingsSaveStatus" class="text-sm text-secondary mr-4"></div>
    <button type="button" class="btn btn-secondary" onclick="closeModal('settingsModal')">Cancel</button>
    <button type="submit" form="settingsForm" class="btn btn-primary">Save Credentials</button>
  </div>
</div>

<div class="pipeline-page">
  <!-- Project Banner -->
  {% if project %}
  <div class="project-banner">
    <div class="project-banner-info">
      <span class="project-banner-name"><i class="bi bi-folder-fill"></i> {{ project.name }}</span>
      {% if session_folder %}
      <span class="project-banner-session">Session: {{ session_folder }}</span>
      {% endif %}
    </div>
    <a href="/project/{{ project.id }}" class="project-banner-back">
      <i class="bi bi-arrow-left"></i> Retour au projet
    </a>
  </div>
  {% endif %}

  <!-- Header -->
  <div class="pipeline-header">
    <h1>RAGpy Data Processing Pipeline</h1>
    <p>Transform your documents into searchable vector embeddings</p>
  </div>

  <!-- Step Tracker -->
  <div class="step-tracker" id="stepTracker">
    <div class="step-item active" data-step="upload">
      <span class="step-number">1</span>
      <span class="step-title">Upload</span>
      <a class="step-file-link" style="display:none"></a>
    </div>
    <div class="step-connector"></div>
    <div class="step-item locked" data-step="extraction">
      <span class="step-number">2</span>
      <span class="step-title">Extraction</span>
      <a class="step-file-link" style="display:none"></a>
    </div>
    <div class="step-connector"></div>
    <div class="step-item locked" data-step="processing">
      <span class="step-number">3</span>
      <span class="step-title">Processing</span>
      <a class="step-file-link" style="display:none"></a>
    </div>
    <div class="step-connector"></div>
    <div class="step-item locked" data-step="destination">
      <span class="step-number">4</span>
      <span class="step-title">Destination</span>
      <a class="step-file-link" style="display:none"></a>
    </div>
  </div>

  <!-- Global Controls -->
  <div class="global-controls" id="global-controls">
    <button id="stopAllScriptsBtn" class="danger-btn">
      <i class="bi bi-stop-circle"></i> Stop All Running Scripts
    </button>
    <div id="stopScriptsResult" class="result" style="display: none; margin-top:10px;"></div>
  </div>

  <!-- Step 1: Upload Documents -->
  <section class="pipeline-section" id="upload-section">
    <div class="section-header">
      <span class="section-number">1</span>
      <h2>Upload Documents</h2>
    </div>
    <div class="section-body">
      <p class="text-secondary mb-4">Choose your data source:</p>

      <div class="upload-options">
        <!-- Option A: ZIP -->
        <div class="upload-option option-zip">
          <div class="upload-option-header">
            <span class="upload-option-icon">üì¶</span>
            <span class="upload-option-title">ZIP Archive (Zotero + PDFs)</span>
          </div>
          <p class="upload-option-desc">
            For Zotero exports containing a JSON file + PDF attachments. Requires OCR processing.
          </p>
          <form id="uploadZipForm" enctype="multipart/form-data" class="upload-form">
            <input type="file" name="file" accept=".zip" required>
            <button type="submit" class="btn btn-primary">Upload ZIP</button>
          </form>
        </div>

        <!-- Option B: CSV -->
        <div class="upload-option option-csv">
          <div class="upload-option-header">
            <span class="upload-option-icon">üìÑ</span>
            <span class="upload-option-title">CSV File (Direct Text)</span>
          </div>
          <p class="upload-option-desc">
            For CSV files with a text column. Skips OCR - faster and cheaper.
          </p>
          <form id="uploadCsvForm" enctype="multipart/form-data" class="upload-form">
            <input type="file" name="file" accept=".csv" required>
            <button type="submit" class="btn btn-success">Upload CSV</button>
          </form>
        </div>
      </div>

      <div id="uploadResult" class="result"></div>
    </div>
  </section>

  <!-- Step 2: Process DataFrame -->
  <section class="pipeline-section step-locked" id="dataframe-section">
    <div class="section-header">
      <span class="section-number">2</span>
      <h2>Extract Text & Metadata</h2>
    </div>
    <div class="section-body">
      <button id="processDataframeBtn" class="btn btn-primary">
        <i class="bi bi-file-earmark-text"></i> Generate CSV
      </button>

      <div id="csvProgress" class="progress-container" style="display:none;">
        <!-- Primary progress (rows/documents) -->
        <div class="progress-primary">
          <div class="progress-label">Documents</div>
          <div class="progress-header">
            <span id="csvProgressCount" class="progress-count">0/0</span>
            <span id="csvProgressStatus" class="progress-status">Processing...</span>
          </div>
          <div class="progress-bar-wrapper">
            <div id="csvProgressBar" class="progress-bar-fill"></div>
          </div>
        </div>
        <!-- Secondary progress (chunks/pages) -->
        <div id="csvProgressSecondary" class="progress-secondary">
          <div class="progress-label">Chunks</div>
          <div class="progress-header">
            <span id="csvProgressSecondaryCount" class="progress-count">0/0</span>
            <span id="csvProgressSecondaryStatus" class="progress-status"></span>
          </div>
          <div class="progress-bar-wrapper">
            <div id="csvProgressSecondaryBar" class="progress-bar-fill"></div>
          </div>
        </div>
      </div>

      <div id="dataframeResult" class="result"></div>
    </div>
  </section>

  <!-- Decision Tree -->
  <div class="decision-tree step-locked" id="decision-tree">
    <div class="decision-tree-header">
      <h2>3. Choose Your Destination</h2>
      <p class="tree-subtitle">Select one option</p>
    </div>

    <div class="branches-container">
      <!-- RAG Branch -->
      <div class="branch branch-rag selected" id="rag-branch">
        <div class="branch-header">
          <input type="radio" name="destination-choice" id="rag-checkbox" checked>
          <label for="rag-checkbox">
            <span class="branch-icon">üîç</span>
            <span class="branch-title">Feed a RAG</span>
          </label>
        </div>
        <div class="branch-content">
          <!-- 3.1 Initial Chunking -->
          <div class="sub-section" id="initial-chunk-section">
            <h3>3.1 Initial Text Chunking</h3>
            <div class="sub-section-warning">
              <i class="bi bi-exclamation-triangle"></i>
              This process can take a long time. We recommend processing max 10 articles at a time.
            </div>

            <form id="initialChunkUploadForm" enctype="multipart/form-data" class="stage-upload-form">
              <input type="file" id="initialChunkUploadInput" name="file" accept=".csv">
              <button type="submit" class="btn btn-secondary btn-sm">Upload CSV</button>
            </form>

            <div class="model-input-group">
              <label for="recodingModelInput">Recoding Model (optional)</label>
              <input type="text" id="recodingModelInput" placeholder="openai/gemini-2.5-flash">
              <p class="model-input-hint">Leave empty for default. Format: "provider/model" (OpenRouter) or "gpt-4o-mini" (OpenAI)</p>
            </div>

            <button id="runInitialChunkBtn" class="btn btn-primary">
              <i class="bi bi-scissors"></i> Generate Chunks
            </button>

            <div id="initialChunkProgress" class="progress-container" style="display:none;">
              <!-- Primary progress (rows/documents) -->
              <div class="progress-primary">
                <div class="progress-label">Documents</div>
                <div class="progress-header">
                  <span id="initialChunkProgressCount" class="progress-count">0/0</span>
                  <span id="initialChunkProgressStatus" class="progress-status">Processing...</span>
                </div>
                <div class="progress-bar-wrapper">
                  <div id="initialChunkProgressBar" class="progress-bar-fill"></div>
                </div>
              </div>
              <!-- Secondary progress (chunks) -->
              <div id="initialChunkProgressSecondary" class="progress-secondary">
                <div class="progress-label">Chunks</div>
                <div class="progress-header">
                  <span id="initialChunkProgressSecondaryCount" class="progress-count">0/0</span>
                  <span id="initialChunkProgressSecondaryStatus" class="progress-status"></span>
                </div>
                <div class="progress-bar-wrapper">
                  <div id="initialChunkProgressSecondaryBar" class="progress-bar-fill"></div>
                </div>
              </div>
            </div>

            <div id="initialChunkResult" class="result"></div>
          </div>

          <!-- 3.2 Dense Embeddings -->
          <div class="sub-section step-locked" id="dense-embedding-section">
            <h3>3.2 Dense Embedding Generation</h3>
            <form id="denseUploadForm" enctype="multipart/form-data" class="stage-upload-form">
              <input type="file" id="denseUploadInput" name="file" accept=".json">
              <button type="submit" class="btn btn-secondary btn-sm">Upload Chunks</button>
            </form>
            <button id="runDenseEmbeddingBtn" class="btn btn-primary">
              <i class="bi bi-grid-3x3-gap"></i> Generate Dense Embeddings
            </button>

            <div id="denseEmbeddingProgress" class="progress-container" style="display:none;">
              <!-- Primary progress (chunks only - documents were processed in 3.1) -->
              <div class="progress-primary">
                <div class="progress-label">Chunks</div>
                <div class="progress-header">
                  <span id="denseEmbeddingProgressCount" class="progress-count">0/0</span>
                  <span id="denseEmbeddingProgressStatus" class="progress-status">Processing...</span>
                </div>
                <div class="progress-bar-wrapper">
                  <div id="denseEmbeddingProgressBar" class="progress-bar-fill"></div>
                </div>
              </div>
            </div>

            <div id="denseEmbeddingResult" class="result"></div>
          </div>

          <!-- 3.3 Sparse Embeddings -->
          <div class="sub-section step-locked" id="sparse-embedding-section">
            <h3>3.3 Sparse Embedding Generation</h3>
            <form id="sparseUploadForm" enctype="multipart/form-data" class="stage-upload-form">
              <input type="file" id="sparseUploadInput" name="file" accept=".json">
              <button type="submit" class="btn btn-secondary btn-sm">Upload Dense</button>
            </form>
            <button id="runSparseEmbeddingBtn" class="btn btn-primary">
              <i class="bi bi-grid"></i> Generate Sparse Embeddings
            </button>

            <div id="sparseEmbeddingProgress" class="progress-container" style="display:none;">
              <!-- Primary progress (chunks) -->
              <div class="progress-primary">
                <div class="progress-label">Chunks</div>
                <div class="progress-header">
                  <span id="sparseEmbeddingProgressCount" class="progress-count">0/0</span>
                  <span id="sparseEmbeddingProgressStatus" class="progress-status">Processing...</span>
                </div>
                <div class="progress-bar-wrapper">
                  <div id="sparseEmbeddingProgressBar" class="progress-bar-fill"></div>
                </div>
              </div>
            </div>

            <div id="sparseEmbeddingResult" class="result"></div>
          </div>

          <!-- 4. Vector DB Upload -->
          <div class="sub-section step-locked" id="db-section">
            <h3>4. Upload to Vector Database</h3>
            <p class="text-secondary text-sm mb-4">Store embeddings for semantic search and RAG applications.</p>

            <div class="db-options" id="vectorDbOptions">
              <div class="db-select-group">
                <label class="form-label" for="dbChoice">Choose Database</label>
                <select id="dbChoice" class="form-select">
                  <option value="pinecone">Pinecone</option>
                  <option value="weaviate">Weaviate</option>
                  <option value="qdrant">Qdrant</option>
                </select>
              </div>

              <div id="pineconeParams" class="db-params">
                <div>
                  <label for="pineconeIndexName">Index Name</label>
                  <input type="text" id="pineconeIndexName" name="pinecone_index_name" value="articles" placeholder="e.g., articles">
                </div>
                <div>
                  <label for="pineconeNamespace">Namespace (optional)</label>
                  <input type="text" id="pineconeNamespace" name="pinecone_namespace" placeholder="e.g., workshop">
                </div>
              </div>

              <div id="weaviateParams" class="db-params" style="display:none;">
                <div>
                  <label for="weaviateClassName">Class Name</label>
                  <input type="text" id="weaviateClassName" name="weaviate_class_name" value="Article" placeholder="e.g., Article">
                </div>
                <div>
                  <label for="weaviateTenantName">Tenant Name</label>
                  <input type="text" id="weaviateTenantName" name="weaviate_tenant_name" value="alakel" placeholder="e.g., alakel">
                </div>
              </div>

              <div id="qdrantParams" class="db-params" style="display:none;">
                <div>
                  <label for="qdrantCollectionName">Collection Name</label>
                  <input type="text" id="qdrantCollectionName" name="qdrant_collection_name" placeholder="e.g., my_documents" required>
                </div>
              </div>

              <button id="uploadDbBtn" class="btn btn-primary">
                <i class="bi bi-cloud-upload"></i> Upload to Vector DB
              </button>
              <div id="dbResult" class="result"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Zotero Branch -->
      <div class="branch branch-zotero" id="zotero-branch">
        <div class="branch-header">
          <input type="radio" name="destination-choice" id="zotero-checkbox">
          <label for="zotero-checkbox">
            <span class="branch-icon">üìù</span>
            <span class="branch-title">Zotero Notes</span>
          </label>
        </div>
        <div class="branch-content">
          <div class="sub-section" id="zotero-notes-section">
            <h3>Generate Zotero Reading Notes</h3>
            <p class="text-secondary text-sm mb-4">
              Generate AI-powered reading notes and add them to your Zotero library.
              <strong>Only available for Zotero exports.</strong>
            </p>

            <div class="zotero-options">
              <div class="zotero-checkbox-group">
                <input type="checkbox" id="extendedAnalysisCheckbox" checked>
                <div class="zotero-checkbox-label">
                  <strong>Extended Analysis</strong>
                  <small>
                    <strong>Checked:</strong> Creates detailed child note (8000-12000 words) with methodology and bibliography.<br>
                    <strong>Unchecked:</strong> Enriches Abstract field with a summary (200-350 words).
                  </small>
                </div>
              </div>

              <div class="model-input-group">
                <label for="zoteroModelInput">LLM Model (optional)</label>
                <input type="text" id="zoteroModelInput" placeholder="openai/gemini-2.5-flash or gpt-4o-mini">
                <p class="model-input-hint">Leave empty for default (gpt-4o-mini).</p>
              </div>
            </div>

            <button id="generateZoteroNotesBtn" class="btn btn-primary" style="background: #8B5CF6; border-color: #8B5CF6;">
              <i class="bi bi-journal-bookmark"></i> Generate Zotero Notes
            </button>

            <div id="zoteroProgress" class="progress-container" style="display:none;">
              <!-- Global progress header -->
              <div class="progress-header">
                <span id="zoteroProgressCount" class="progress-count">0/0</span>
                <span id="zoteroProgressStatus" class="progress-status">Processing...</span>
              </div>
              <!-- Global progress bar -->
              <div class="progress-bar-wrapper">
                <div id="zoteroProgressBar" class="progress-bar-fill zotero"></div>
              </div>
              <!-- Multi-item progress container -->
              <div id="zoteroMultiProgress" class="multi-progress-container">
                <!-- Mini-bars will be dynamically inserted here -->
              </div>
              <p id="zoteroProgressText" class="text-sm text-tertiary mt-2"></p>
            </div>

            <div id="zoteroLog" class="result" style="max-height: 400px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
  // ========================================
  // STATE MANAGEMENT
  // ========================================
  const appState = {
    currentPath: '',
    steps: {
      upload: { completed: false, file: null },
      extraction: { completed: false, file: 'output.csv' },
      chunking: { completed: false, file: 'output_chunks.json' },
      denseEmbed: { completed: false, file: 'output_chunks_with_embeddings.json' },
      sparseEmbed: { completed: false, file: 'output_chunks_with_embeddings_sparse.json' },
      vectorDb: { completed: false, file: null },
      zoteroNotes: { completed: false, file: null }
    },
    selectedBranches: {
      rag: true,
      zotero: false
    },
    isZoteroExport: false
  };

  // ========================================
  // STEP TRACKER FUNCTIONS
  // ========================================
  function updateStepTracker(stepName, status) {
    const stepMapping = {
      'upload': 'upload',
      'extraction': 'extraction',
      'chunking': 'processing',
      'denseEmbed': 'processing',
      'sparseEmbed': 'processing',
      'vectorDb': 'destination',
      'zoteroNotes': 'destination'
    };

    const trackerStep = stepMapping[stepName];
    if (!trackerStep) return;

    const stepEl = document.querySelector(`.step-item[data-step="${trackerStep}"]`);
    if (!stepEl) return;

    const allSteps = ['upload', 'extraction', 'processing', 'destination'];
    const stepIndex = allSteps.indexOf(trackerStep);

    if (status === 'completed') {
      stepEl.classList.remove('active', 'locked');
      stepEl.classList.add('completed');

      const connectors = document.querySelectorAll('.step-connector');
      if (stepIndex > 0 && connectors[stepIndex - 1]) {
        connectors[stepIndex - 1].classList.add('completed');
      }

      if (stepIndex < allSteps.length - 1) {
        const nextStepEl = document.querySelector(`.step-item[data-step="${allSteps[stepIndex + 1]}"]`);
        if (nextStepEl && nextStepEl.classList.contains('locked')) {
          nextStepEl.classList.remove('locked');
          nextStepEl.classList.add('active');
        }
      }

      const fileLink = stepEl.querySelector('.step-file-link');
      const stepData = appState.steps[stepName];
      if (fileLink && stepData && stepData.file && appState.currentPath) {
        fileLink.href = `/download_file?session_path=${encodeURIComponent(appState.currentPath)}&filename=${encodeURIComponent(stepData.file)}`;
        fileLink.textContent = `üìé ${stepData.file}`;
        fileLink.style.display = 'inline-flex';
      }
    } else if (status === 'active') {
      stepEl.classList.remove('completed', 'locked');
      stepEl.classList.add('active');
    }
  }

  function completeStep(stepName, fileName) {
    appState.steps[stepName].completed = true;
    if (fileName) {
      appState.steps[stepName].file = fileName;
    }
    updateStepTracker(stepName, 'completed');
  }

  // ========================================
  // SECTION UNLOCK FUNCTIONS
  // ========================================
  function unlockSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
      section.classList.remove('step-locked');
      section.classList.add('step-available', 'fade-in');
    }
  }

  function lockSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
      section.classList.remove('step-available', 'fade-in');
      section.classList.add('step-locked');
    }
  }

  function markSectionCompleted(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
      section.classList.add('step-completed');
    }
  }

  function unlockDecisionTree() {
    const tree = document.getElementById('decision-tree');
    if (tree) {
      tree.classList.remove('step-locked');
      tree.classList.add('fade-in');
      updateStepTracker('extraction', 'completed');
    }
  }

  // ========================================
  // BRANCH TOGGLE FUNCTIONS
  // ========================================
  function toggleBranch(branchName, enabled) {
    appState.selectedBranches[branchName] = enabled;
    const branch = document.getElementById(`${branchName}-branch`);
    if (branch) {
      branch.classList.toggle('selected', enabled);
    }
  }

  // Radio button behavior - mutually exclusive branches
  document.getElementById('rag-checkbox').addEventListener('change', (e) => {
    if (e.target.checked) {
      toggleBranch('rag', true);
      toggleBranch('zotero', false);
    }
  });

  document.getElementById('zotero-checkbox').addEventListener('change', (e) => {
    if (e.target.checked) {
      toggleBranch('zotero', true);
      toggleBranch('rag', false);
    }
  });

  // ========================================
  // SETTINGS MODAL
  // ========================================
  const settingsForm = document.getElementById('settingsForm');
  const settingsSaveStatus = document.getElementById('settingsSaveStatus');

  async function loadCredentials() {
    settingsSaveStatus.textContent = 'Loading credentials...';
    try {
      const res = await fetch('/get_credentials');
      if (!res.ok) {
        settingsSaveStatus.textContent = `Error ${res.status}`;
        return;
      }
      const json = await res.json();
      for (const key in json) {
        const input = document.querySelector(`#settingsForm [name="${key}"]`);
        if (input) {
          const value = json[key] || '';
          const isApiKey = key.includes('API_KEY') || key.includes('_KEY');
          if (isApiKey && value.length > 20) {
            input.value = value.substring(0, 20) + '##########';
          } else {
            input.value = value;
          }
          input.dataset.fullValue = value;
        }
      }
      settingsSaveStatus.textContent = '';
    } catch (err) {
      settingsSaveStatus.textContent = "Error: " + err.message;
    }
  }

  // Load credentials when modal opens
  const settingsModal = document.getElementById('settingsModal');
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class' && settingsModal.classList.contains('active')) {
        loadCredentials();
      }
    });
  });
  observer.observe(settingsModal, { attributes: true });

  settingsForm.onsubmit = async (e) => {
    e.preventDefault();
    settingsSaveStatus.textContent = 'Saving...';
    const data = {};
    Array.from(settingsForm.elements).forEach(el => {
      if (el.name) {
        if (el.dataset && el.dataset.fullValue &&
            el.value.endsWith('##########') &&
            el.value.startsWith(el.dataset.fullValue.substring(0, 20))) {
          data[el.name] = el.dataset.fullValue;
        } else {
          data[el.name] = el.value;
        }
      }
    });
    try {
      const res = await fetch('/save_credentials', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      const json = await res.json();
      if (res.ok && json.status === "success") {
        settingsSaveStatus.textContent = "Credentials saved!";
        showToast('Credentials saved successfully!', 'success');
        setTimeout(() => closeModal('settingsModal'), 1500);
      } else {
        settingsSaveStatus.textContent = "Error: " + (json.error || "Could not save.");
      }
    } catch (err) {
      settingsSaveStatus.textContent = "Request failed: " + err;
    }
  };

  // Project and Session context
  const projectId = {{ project_id or 'null' }};
  const sessionFolder = '{{ session_folder or "" }}';
  let currentPath = '';

  // Load existing session
  async function loadExistingSession() {
    if (!sessionFolder) return;
    currentPath = sessionFolder;
    appState.currentPath = sessionFolder;

    try {
      const response = await fetch(`/api/pipeline/sessions/${encodeURIComponent(sessionFolder)}/files`);
      if (!response.ok) return;

      const data = await response.json();
      const files = data.files;

      if (files.upload.completed) {
        completeStep('upload', null);
        markSectionCompleted('upload-section');
        unlockSection('dataframe-section');
        updateStepTracker('upload', 'completed');
        document.getElementById('uploadResult').innerHTML = `<p>‚úÖ Session loaded: <strong>${sessionFolder}</strong></p>`;
      }

      if (files.extraction.completed) {
        completeStep('extraction', 'output.csv');
        markSectionCompleted('dataframe-section');
        unlockDecisionTree();
        const rowInfo = files.extraction.row_count ? ` (${files.extraction.row_count} rows)` : '';
        document.getElementById('dataframeResult').innerHTML = `<p>‚úÖ Existing CSV: ${buildDownloadLink('output.csv')}${rowInfo}</p>`;
      }

      if (files.chunking.completed) {
        completeStep('chunking', 'output_chunks.json');
        markSectionCompleted('initial-chunk-section');
        unlockSection('dense-embedding-section');
        const chunkInfo = files.chunking.chunk_count ? ` (${files.chunking.chunk_count} chunks)` : '';
        document.getElementById('initialChunkResult').innerHTML = `<p>‚úÖ Existing chunks: ${buildDownloadLink('output_chunks.json')}${chunkInfo}</p>`;
      }

      if (files.dense_embedding.completed) {
        completeStep('denseEmbed', 'output_chunks_with_embeddings.json');
        markSectionCompleted('dense-embedding-section');
        unlockSection('sparse-embedding-section');
        const denseInfo = files.dense_embedding.chunk_count ? ` (${files.dense_embedding.chunk_count} chunks)` : '';
        document.getElementById('denseEmbeddingResult').innerHTML = `<p>‚úÖ Existing dense embeddings: ${buildDownloadLink('output_chunks_with_embeddings.json')}${denseInfo}</p>`;
      }

      if (files.sparse_embedding.completed) {
        completeStep('sparseEmbed', 'output_chunks_with_embeddings_sparse.json');
        markSectionCompleted('sparse-embedding-section');
        unlockSection('db-section');
        const sparseInfo = files.sparse_embedding.chunk_count ? ` (${files.sparse_embedding.chunk_count} chunks)` : '';
        document.getElementById('sparseEmbeddingResult').innerHTML = `<p>‚úÖ Existing sparse embeddings: ${buildDownloadLink('output_chunks_with_embeddings_sparse.json')}${sparseInfo}</p>`;
      }
    } catch (err) {
      console.error('Error loading session:', err);
    }
  }

  document.addEventListener('DOMContentLoaded', loadExistingSession);

  function ensureSessionPath(resultDiv) {
    if (!appState.currentPath && !currentPath) {
      resultDiv.textContent = 'Session path not initialized. Upload a ZIP or CSV first.';
      return false;
    }
    if (appState.currentPath) currentPath = appState.currentPath;
    return true;
  }

  function buildDownloadLink(filename) {
    return `<a href="/download_file?session_path=${encodeURIComponent(currentPath)}&filename=${encodeURIComponent(filename)}" download="${filename}">${filename}</a>`;
  }

  async function uploadStageArtifact({ stage, fileInput, resultDiv }) {
    if (!ensureSessionPath(resultDiv)) return null;
    if (!fileInput.files || fileInput.files.length === 0) {
      resultDiv.textContent = 'Please choose a file before uploading.';
      return null;
    }
    const formData = new FormData();
    formData.append('path', currentPath);
    formData.append('file', fileInput.files[0]);
    resultDiv.textContent = 'Uploading...';
    try {
      const res = await fetch(`/upload_stage_file/${stage}`, { method: 'POST', body: formData });
      const json = await res.json();
      if (!res.ok || json.status !== 'success') {
        resultDiv.textContent = `Error: ${json.error || 'Upload failed.'}`;
        return null;
      }
      return json;
    } catch (err) {
      resultDiv.textContent = `Upload failed: ${err}`;
      return null;
    }
  }

  function formatUploadSummary(details) {
    if (!details || typeof details !== 'object') return '';
    const parts = [];
    if (typeof details.rows === 'number') parts.push(`Rows: <strong>${details.rows}</strong>`);
    if (typeof details.columns === 'number') parts.push(`Columns: <strong>${details.columns}</strong>`);
    if (typeof details.count === 'number') parts.push(`Items: <strong>${details.count}</strong>`);
    if (details.parse_warning) parts.push(`<span class="error-text">${details.parse_warning}</span>`);
    return parts.length ? `<p>${parts.join(' ‚Ä¢ ')}</p>` : '';
  }

  // Step 1A: Upload ZIP
  document.getElementById('uploadZipForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const uploadResult = document.getElementById('uploadResult');
    uploadResult.textContent = 'Uploading ZIP...';
    const formData = new FormData(e.target);
    if (projectId) formData.append('project_id', projectId);
    try {
      const res = await fetch('/upload_zip', { method: 'POST', body: formData });
      const json = await res.json();
      if (res.ok) {
        currentPath = json.path;
        appState.currentPath = json.path;
        appState.isZoteroExport = true;
        uploadResult.innerHTML = `<p>‚úÖ ZIP uploaded: <strong>${currentPath}</strong></p>`;
        completeStep('upload', null);
        markSectionCompleted('upload-section');
        unlockSection('dataframe-section');
        showToast('ZIP uploaded successfully!', 'success');
      } else {
        uploadResult.textContent = 'Error: ' + (json.error || res.statusText);
      }
    } catch (err) {
      uploadResult.textContent = 'Upload failed: ' + err;
    }
  });

  // Step 1B: Upload CSV
  document.getElementById('uploadCsvForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const uploadResult = document.getElementById('uploadResult');
    uploadResult.textContent = 'Uploading CSV...';
    const formData = new FormData(e.target);
    if (projectId) formData.append('project_id', projectId);
    try {
      const res = await fetch('/upload_csv', { method: 'POST', body: formData });
      const json = await res.json();
      if (res.ok) {
        currentPath = json.path;
        appState.currentPath = json.path;
        appState.isZoteroExport = false;
        uploadResult.innerHTML = `<p>‚úÖ CSV ingested: <strong>${currentPath}</strong></p>`;
        completeStep('upload', null);
        completeStep('extraction', 'output.csv');
        markSectionCompleted('upload-section');
        lockSection('dataframe-section');
        unlockDecisionTree();
        showToast('CSV processed successfully!', 'success');
      } else {
        uploadResult.textContent = 'Error: ' + (json.error || res.statusText);
      }
    } catch (err) {
      uploadResult.textContent = 'Upload failed: ' + err;
    }
  });

  // ========================================
  // MULTILEVEL PROGRESS HANDLER
  // ========================================
  function createMultilevelProgressHandler(config) {
    /**
     * Creates a handler for multilevel SSE progress events.
     *
     * config: {
     *   primaryBar, primaryCount, primaryStatus,
     *   secondaryContainer, secondaryBar, secondaryCount, secondaryStatus (optional),
     *   primaryLabel (default: 'row'), secondaryLabel (default: 'chunk')
     * }
     */
    let primaryTotal = 0;
    let secondaryTotal = 0;

    return function handleProgressEvent(data) {
      const level = data.level || 'row';  // Default to row if no level specified

      if (data.type === 'init') {
        primaryTotal = data.total || 0;
        config.primaryCount.textContent = `0/${primaryTotal}`;
        config.primaryStatus.textContent = data.message || 'Processing...';
        config.primaryBar.style.width = '0%';
        // Reset secondary
        if (config.secondaryContainer) {
          config.secondaryContainer.classList.remove('active');
          config.secondaryBar.style.width = '0%';
        }
      } else if (data.type === 'progress') {
        if (level === 'row' || level === config.primaryLabel) {
          // Primary progress (documents/rows)
          const percent = data.percent || Math.round((data.current / data.total) * 100);
          config.primaryBar.style.width = `${percent}%`;
          config.primaryCount.textContent = `${data.current}/${data.total}`;
          config.primaryStatus.textContent = data.message || `Processing ${data.current}/${data.total}`;
          primaryTotal = data.total;
          // Reset secondary when moving to new row
          if (config.secondaryContainer && config.secondaryBar) {
            config.secondaryBar.style.width = '0%';
          }
        } else if ((level === 'chunk' || level === config.secondaryLabel) && config.secondaryContainer) {
          // Secondary progress (chunks)
          config.secondaryContainer.classList.add('active');
          const percent = data.percent || Math.round((data.current / data.total) * 100);
          config.secondaryBar.style.width = `${percent}%`;
          config.secondaryCount.textContent = `${data.current}/${data.total}`;
          config.secondaryStatus.textContent = data.message || `Chunk ${data.current}/${data.total}`;
          secondaryTotal = data.total;
        }
      }

      return { primaryTotal, secondaryTotal };
    };
  }

  // Step 2: Process DataFrame with SSE
  document.getElementById('processDataframeBtn').addEventListener('click', async () => {
    const resultDiv = document.getElementById('dataframeResult');
    const progressDiv = document.getElementById('csvProgress');
    const progressBar = document.getElementById('csvProgressBar');
    const progressCount = document.getElementById('csvProgressCount');
    const progressStatus = document.getElementById('csvProgressStatus');
    const secondaryContainer = document.getElementById('csvProgressSecondary');
    const secondaryBar = document.getElementById('csvProgressSecondaryBar');
    const secondaryCount = document.getElementById('csvProgressSecondaryCount');
    const secondaryStatus = document.getElementById('csvProgressSecondaryStatus');

    if (!ensureSessionPath(resultDiv)) return;

    resultDiv.innerHTML = '';
    progressDiv.style.display = 'block';
    progressBar.style.width = '0%';
    progressCount.textContent = '0/0';
    progressStatus.textContent = 'Starting...';
    secondaryContainer.classList.remove('active');

    // Track document total for final count display
    let lastTotal = 0;

    const handleProgress = createMultilevelProgressHandler({
      primaryBar: progressBar,
      primaryCount: progressCount,
      primaryStatus: progressStatus,
      secondaryContainer: secondaryContainer,
      secondaryBar: secondaryBar,
      secondaryCount: secondaryCount,
      secondaryStatus: secondaryStatus,
      primaryLabel: 'row',
      secondaryLabel: 'chunk'
    });

    const formData = new FormData();
    formData.append('path', currentPath);

    try {
      const response = await fetch('/process_dataframe_sse', { method: 'POST', body: formData });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.substring(6));
              if (data.type === 'init' || data.type === 'progress') {
                handleProgress(data);
                // Track total for final display
                if (data.total) {
                  lastTotal = data.total;
                }
              } else if (data.type === 'complete') {
                progressBar.style.width = '100%';
                // Update count to show final total
                if (lastTotal > 0) {
                  progressCount.textContent = `${lastTotal}/${lastTotal}`;
                }
                progressStatus.textContent = 'Complete!';
                secondaryContainer.classList.remove('active');
                resultDiv.innerHTML = `<p>‚úÖ File generated: ${buildDownloadLink('output.csv')}</p>`;
                completeStep('extraction', 'output.csv');
                markSectionCompleted('dataframe-section');
                unlockDecisionTree();
                showToast('CSV generated successfully!', 'success');
              } else if (data.type === 'error') {
                progressStatus.textContent = 'Error';
                resultDiv.innerHTML = `<p class="error-text">Error: ${data.message}</p>`;
              }
            } catch (e) {
              console.error('Failed to parse SSE:', e);
            }
          }
        }
      }
    } catch (err) {
      progressStatus.textContent = 'Failed';
      resultDiv.innerHTML = `<p class="error-text">Processing failed: ${err}</p>`;
    }
  });

  // Step 3.1: Initial Chunking with SSE
  document.getElementById('runInitialChunkBtn').addEventListener('click', async () => {
    const resultDiv = document.getElementById('initialChunkResult');
    const progressDiv = document.getElementById('initialChunkProgress');
    const progressBar = document.getElementById('initialChunkProgressBar');
    const progressCount = document.getElementById('initialChunkProgressCount');
    const progressStatus = document.getElementById('initialChunkProgressStatus');
    const secondaryContainer = document.getElementById('initialChunkProgressSecondary');
    const secondaryBar = document.getElementById('initialChunkProgressSecondaryBar');
    const secondaryCount = document.getElementById('initialChunkProgressSecondaryCount');
    const secondaryStatus = document.getElementById('initialChunkProgressSecondaryStatus');

    if (!ensureSessionPath(resultDiv)) return;

    resultDiv.innerHTML = '';
    progressDiv.style.display = 'block';
    progressBar.style.width = '0%';
    progressCount.textContent = '0/0';
    progressStatus.textContent = 'Starting chunking...';
    secondaryContainer.classList.remove('active');

    // Track document total for final count display
    let lastDocumentTotal = 0;

    const handleProgress = createMultilevelProgressHandler({
      primaryBar: progressBar,
      primaryCount: progressCount,
      primaryStatus: progressStatus,
      secondaryContainer: secondaryContainer,
      secondaryBar: secondaryBar,
      secondaryCount: secondaryCount,
      secondaryStatus: secondaryStatus,
      primaryLabel: 'row',
      secondaryLabel: 'chunk'
    });

    const formData = new FormData();
    formData.append('path', currentPath);
    const model = document.getElementById('recodingModelInput').value.trim();
    if (model) formData.append('model', model);

    try {
      const response = await fetch('/initial_text_chunking_sse', { method: 'POST', body: formData });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.substring(6));
              if (data.type === 'init' || data.type === 'progress') {
                handleProgress(data);
                // Track document total for final display
                if (data.level === 'row' && data.total) {
                  lastDocumentTotal = data.total;
                } else if (data.type === 'init' && data.total) {
                  lastDocumentTotal = data.total;
                }
              } else if (data.type === 'complete') {
                progressBar.style.width = '100%';
                // Update count to show final document count
                if (lastDocumentTotal > 0) {
                  progressCount.textContent = `${lastDocumentTotal}/${lastDocumentTotal}`;
                }
                progressStatus.textContent = 'Complete!';
                secondaryContainer.classList.remove('active');
                const fileName = 'output_chunks.json';
                resultDiv.innerHTML = `<p>‚úÖ File generated: ${buildDownloadLink(fileName)}</p><p>Chunks: <strong>${data.count || 'N/A'}</strong></p>`;
                completeStep('chunking', fileName);
                markSectionCompleted('initial-chunk-section');
                unlockSection('dense-embedding-section');
                showToast('Chunks generated successfully!', 'success');
              } else if (data.type === 'error') {
                progressStatus.textContent = 'Error';
                resultDiv.innerHTML = `<p class="error-text">Error: ${data.message}</p>`;
              }
            } catch (e) {
              console.error('Failed to parse SSE:', e);
            }
          }
        }
      }
    } catch (err) {
      progressStatus.textContent = 'Failed';
      resultDiv.innerHTML = `<p class="error-text">Request failed: ${err}</p>`;
    }
  });

  document.getElementById('initialChunkUploadForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const resultDiv = document.getElementById('initialChunkResult');
    const fileInput = document.getElementById('initialChunkUploadInput');
    const response = await uploadStageArtifact({ stage: 'initial', fileInput, resultDiv });
    if (!response) return;
    resultDiv.innerHTML = `<p>‚úÖ CSV uploaded: ${buildDownloadLink(response.filename)}</p>${formatUploadSummary(response.details)}`;
    fileInput.value = '';
    markSectionCompleted('initial-chunk-section');
    unlockSection('dense-embedding-section');
  });

  // Step 3.2: Dense Embeddings with SSE (chunks only - documents were processed in 3.1)
  document.getElementById('runDenseEmbeddingBtn').addEventListener('click', async () => {
    const resultDiv = document.getElementById('denseEmbeddingResult');
    const progressDiv = document.getElementById('denseEmbeddingProgress');
    const progressBar = document.getElementById('denseEmbeddingProgressBar');
    const progressCount = document.getElementById('denseEmbeddingProgressCount');
    const progressStatus = document.getElementById('denseEmbeddingProgressStatus');

    if (!ensureSessionPath(resultDiv)) return;

    resultDiv.innerHTML = '';
    progressDiv.style.display = 'block';
    progressBar.style.width = '0%';
    progressCount.textContent = '0/0';
    progressStatus.textContent = 'Generating dense embeddings...';

    // Track chunk total for final count display (fallback if data.count missing)
    let lastChunkTotal = 0;

    const handleProgress = createMultilevelProgressHandler({
      primaryBar: progressBar,
      primaryCount: progressCount,
      primaryStatus: progressStatus,
      secondaryContainer: null,
      primaryLabel: 'chunk',
      secondaryLabel: null
    });

    const formData = new FormData();
    formData.append('path', currentPath);

    try {
      const response = await fetch('/dense_embedding_generation_sse', { method: 'POST', body: formData });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.substring(6));
              if (data.type === 'init' || data.type === 'progress') {
                handleProgress(data);
                // Track total for final display
                if (data.total) {
                  lastChunkTotal = data.total;
                }
              } else if (data.type === 'complete') {
                progressBar.style.width = '100%';
                // Update count: prefer data.count, fallback to tracked total
                const finalCount = data.count || lastChunkTotal;
                if (finalCount > 0) {
                  progressCount.textContent = `${finalCount}/${finalCount}`;
                }
                progressStatus.textContent = 'Complete!';
                const fileName = 'output_chunks_with_embeddings.json';
                resultDiv.innerHTML = `<p>‚úÖ File generated: ${buildDownloadLink(fileName)}</p><p>Chunks: <strong>${finalCount || 'N/A'}</strong></p>`;
                completeStep('denseEmbed', fileName);
                markSectionCompleted('dense-embedding-section');
                unlockSection('sparse-embedding-section');
                showToast('Dense embeddings generated!', 'success');
              } else if (data.type === 'error') {
                progressStatus.textContent = 'Error';
                resultDiv.innerHTML = `<p class="error-text">Error: ${data.message}</p>`;
              }
            } catch (e) {
              console.error('Failed to parse SSE:', e);
            }
          }
        }
      }
    } catch (err) {
      progressStatus.textContent = 'Failed';
      resultDiv.innerHTML = `<p class="error-text">Request failed: ${err}</p>`;
    }
  });

  document.getElementById('denseUploadForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const resultDiv = document.getElementById('denseEmbeddingResult');
    const fileInput = document.getElementById('denseUploadInput');
    const response = await uploadStageArtifact({ stage: 'dense', fileInput, resultDiv });
    if (!response) return;
    resultDiv.innerHTML = `<p>‚úÖ Chunks JSON uploaded: ${buildDownloadLink(response.filename)}</p>${formatUploadSummary(response.details)}`;
    fileInput.value = '';
    markSectionCompleted('dense-embedding-section');
    unlockSection('sparse-embedding-section');
  });

  // Step 3.3: Sparse Embeddings with SSE
  document.getElementById('runSparseEmbeddingBtn').addEventListener('click', async () => {
    const resultDiv = document.getElementById('sparseEmbeddingResult');
    const progressDiv = document.getElementById('sparseEmbeddingProgress');
    const progressBar = document.getElementById('sparseEmbeddingProgressBar');
    const progressCount = document.getElementById('sparseEmbeddingProgressCount');
    const progressStatus = document.getElementById('sparseEmbeddingProgressStatus');

    if (!ensureSessionPath(resultDiv)) return;

    resultDiv.innerHTML = '';
    progressDiv.style.display = 'block';
    progressBar.style.width = '0%';
    progressCount.textContent = '0/0';
    progressStatus.textContent = 'Generating sparse embeddings...';

    // Track chunk total for final count display (fallback if data.count missing)
    let lastChunkTotal = 0;

    const handleProgress = createMultilevelProgressHandler({
      primaryBar: progressBar,
      primaryCount: progressCount,
      primaryStatus: progressStatus,
      secondaryContainer: null,
      primaryLabel: 'chunk',
      secondaryLabel: null
    });

    const formData = new FormData();
    formData.append('path', currentPath);

    try {
      const response = await fetch('/sparse_embedding_generation_sse', { method: 'POST', body: formData });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.substring(6));
              if (data.type === 'init' || data.type === 'progress') {
                handleProgress(data);
                // Track total for final display
                if (data.total) {
                  lastChunkTotal = data.total;
                }
              } else if (data.type === 'complete') {
                progressBar.style.width = '100%';
                // Update count: prefer data.count, fallback to tracked total
                const finalCount = data.count || lastChunkTotal;
                if (finalCount > 0) {
                  progressCount.textContent = `${finalCount}/${finalCount}`;
                }
                progressStatus.textContent = 'Complete!';
                const fileName = 'output_chunks_with_embeddings_sparse.json';
                resultDiv.innerHTML = `<p>‚úÖ File generated: ${buildDownloadLink(fileName)}</p><p>Chunks: <strong>${finalCount || 'N/A'}</strong></p>`;
                completeStep('sparseEmbed', fileName);
                markSectionCompleted('sparse-embedding-section');
                unlockSection('db-section');
                showToast('Sparse embeddings generated!', 'success');
              } else if (data.type === 'error') {
                progressStatus.textContent = 'Error';
                resultDiv.innerHTML = `<p class="error-text">Error: ${data.message}</p>`;
              }
            } catch (e) {
              console.error('Failed to parse SSE:', e);
            }
          }
        }
      }
    } catch (err) {
      progressStatus.textContent = 'Failed';
      resultDiv.innerHTML = `<p class="error-text">Request failed: ${err}</p>`;
    }
  });

  document.getElementById('sparseUploadForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const resultDiv = document.getElementById('sparseEmbeddingResult');
    const fileInput = document.getElementById('sparseUploadInput');
    const response = await uploadStageArtifact({ stage: 'sparse', fileInput, resultDiv });
    if (!response) return;
    resultDiv.innerHTML = `<p>‚úÖ Dense embeddings JSON uploaded: ${buildDownloadLink(response.filename)}</p>${formatUploadSummary(response.details)}`;
    fileInput.value = '';
    markSectionCompleted('sparse-embedding-section');
    unlockSection('db-section');
  });

  // Step 4: Vector DB
  const dbChoiceSelect = document.getElementById('dbChoice');
  const pineconeParamsDiv = document.getElementById('pineconeParams');
  const weaviateParamsDiv = document.getElementById('weaviateParams');
  const qdrantParamsDiv = document.getElementById('qdrantParams');

  dbChoiceSelect.addEventListener('change', function() {
    pineconeParamsDiv.style.display = 'none';
    weaviateParamsDiv.style.display = 'none';
    qdrantParamsDiv.style.display = 'none';
    if (this.value === 'pinecone') pineconeParamsDiv.style.display = 'grid';
    else if (this.value === 'weaviate') weaviateParamsDiv.style.display = 'grid';
    else if (this.value === 'qdrant') qdrantParamsDiv.style.display = 'grid';
  });
  dbChoiceSelect.dispatchEvent(new Event('change'));

  document.getElementById('uploadDbBtn').addEventListener('click', async () => {
    const resultDiv = document.getElementById('dbResult');
    if (!ensureSessionPath(resultDiv)) return;
    resultDiv.textContent = 'Uploading to DB...';
    const form = new URLSearchParams();
    form.append('path', currentPath);
    const dbChoice = dbChoiceSelect.value;
    form.append('db_choice', dbChoice);

    if (dbChoice === 'pinecone') {
      form.append('pinecone_index_name', document.getElementById('pineconeIndexName').value);
      form.append('pinecone_namespace', document.getElementById('pineconeNamespace').value);
    } else if (dbChoice === 'weaviate') {
      form.append('weaviate_class_name', document.getElementById('weaviateClassName').value);
      form.append('weaviate_tenant_name', document.getElementById('weaviateTenantName').value);
    } else if (dbChoice === 'qdrant') {
      const qdrantCollection = document.getElementById('qdrantCollectionName').value;
      if (!qdrantCollection) {
        resultDiv.textContent = 'Error: Qdrant Collection Name is required.';
        return;
      }
      form.append('qdrant_collection_name', qdrantCollection);
    }

    try {
      const res = await fetch('/upload_db', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: form.toString()
      });
      let json = null;
      try { json = await res.json(); } catch (e) {
        resultDiv.textContent = `Error: ${res.status} ${res.statusText}`;
        return;
      }
      if (res.ok && json && json.status) {
        resultDiv.innerHTML = `<p>‚úÖ Status: <strong>${json.status}</strong>. ${json.message || ''}</p>`;
        if (json.inserted_count !== undefined) resultDiv.innerHTML += `<p>Items inserted: ${json.inserted_count}</p>`;
        completeStep('vectorDb', null);
        markSectionCompleted('db-section');
        showToast('Uploaded to vector DB!', 'success');
      } else {
        resultDiv.textContent = `Error: ${json?.error || res.statusText}`;
      }
    } catch (err) {
      resultDiv.textContent = 'DB upload failed: ' + err.message;
    }
  });

  // Zotero Notes
  document.getElementById('generateZoteroNotesBtn').addEventListener('click', async () => {
    const btn = document.getElementById('generateZoteroNotesBtn');
    const resultDiv = document.getElementById('zoteroLog');
    const progressDiv = document.getElementById('zoteroProgress');
    const progressBar = document.getElementById('zoteroProgressBar');
    const progressCount = document.getElementById('zoteroProgressCount');
    const progressStatus = document.getElementById('zoteroProgressStatus');
    const progressText = document.getElementById('zoteroProgressText');
    const multiProgressContainer = document.getElementById('zoteroMultiProgress');

    if (!ensureSessionPath(resultDiv)) return;

    // Prevent double-click - disable button during processing
    if (btn.disabled) {
      showToast('Processing already in progress...', 'warning');
      return;
    }
    const originalBtnHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';

    // Helper to re-enable button
    const resetButton = () => {
      btn.disabled = false;
      btn.innerHTML = originalBtnHtml;
    };

    // Reset UI
    resultDiv.innerHTML = '';
    progressDiv.style.display = 'block';
    progressBar.style.width = '0%';
    progressCount.textContent = '0/0';
    progressStatus.textContent = 'Starting...';
    progressText.textContent = '';
    multiProgressContainer.innerHTML = '';

    const model = document.getElementById('zoteroModelInput').value.trim();
    const extendedAnalysis = document.getElementById('extendedAnalysisCheckbox').checked;

    const formData = new FormData();
    formData.append('session', currentPath);
    formData.append('model', model);
    formData.append('extended_analysis', extendedAnalysis ? 'true' : 'false');

    const processedItems = [];
    const itemElements = new Map(); // Track mini-bar elements by item name

    // Helper: Create or update mini-progress bar
    function updateMiniBar(itemName, status, current, total) {
      const statusIcons = { created: '‚úÖ', exists: '‚ÑπÔ∏è', skipped: '‚è≠Ô∏è', error: '‚ùå', processing: '‚è≥' };
      const statusIcon = statusIcons[status] || '‚è≥';
      const isComplete = ['created', 'exists', 'skipped', 'error'].includes(status);
      const itemId = `mini-${itemName.replace(/[^a-zA-Z0-9]/g, '_')}`;

      let element = itemElements.get(itemName);

      if (!element) {
        // Create new mini-bar
        element = document.createElement('div');
        element.id = itemId;
        element.className = 'mini-progress-item';
        element.innerHTML = `
          <span class="mini-progress-icon">${statusIcon}</span>
          <div class="mini-progress-info">
            <div class="mini-progress-title" title="${itemName}">${itemName}</div>
            <div class="mini-progress-bar-wrapper">
              <div class="mini-progress-bar processing"></div>
            </div>
          </div>
          <span class="mini-progress-status">${status}</span>
        `;
        // Insert at top (newest first)
        multiProgressContainer.insertBefore(element, multiProgressContainer.firstChild);
        itemElements.set(itemName, element);
      }

      // Update existing element
      const iconEl = element.querySelector('.mini-progress-icon');
      const barEl = element.querySelector('.mini-progress-bar');
      const statusEl = element.querySelector('.mini-progress-status');

      iconEl.textContent = statusIcon;
      statusEl.textContent = status;

      if (isComplete) {
        element.classList.remove('processing');
        element.classList.add(status);
        barEl.classList.remove('processing');
        barEl.style.width = '100%';
      } else {
        barEl.style.width = '50%'; // Indeterminate progress for processing items
      }

      // Auto-scroll to show latest
      multiProgressContainer.scrollTop = 0;
    }

    try {
      const response = await fetch('/generate_zotero_notes_sse', { method: 'POST', body: formData });
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let totalItems = 0;
      let completedCount = 0;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.substring(6));

              if (data.type === 'init') {
                totalItems = data.total;
                progressCount.textContent = `0/${totalItems}`;
                progressStatus.textContent = data.message || 'Processing...';

              } else if (data.type === 'progress') {
                const itemName = data.item || `Item ${data.current}`;
                const status = data.status || 'processing';

                // Update global progress bar
                completedCount = data.current;
                const percent = Math.round((completedCount / totalItems) * 100);
                progressBar.style.width = `${percent}%`;
                progressCount.textContent = `${completedCount}/${totalItems}`;
                progressStatus.textContent = `Processing ${completedCount}/${totalItems}...`;

                // Update mini-bar for this item
                updateMiniBar(itemName, status, data.current, totalItems);

                // Store for final summary
                if (data.item) processedItems.push(data);

              } else if (data.type === 'complete') {
                progressBar.style.width = '100%';
                progressStatus.textContent = 'Complete!';
                progressText.textContent = '';

                const s = data.summary;
                let html = `<div class="alert alert-success mb-4">
                  <strong>Summary:</strong>
                  ‚úÖ Created: ${s.created} |
                  ‚ÑπÔ∏è Exists: ${s.exists} |
                  ‚è≠Ô∏è Skipped: ${s.skipped} |
                  ‚ùå Errors: ${s.errors}
                </div>`;
                resultDiv.innerHTML = html;

                completeStep('zoteroNotes', null);
                markSectionCompleted('zotero-notes-section');
                showToast('Zotero notes generated!', 'success');
                resetButton();

              } else if (data.type === 'error') {
                progressStatus.textContent = 'Error';
                resultDiv.innerHTML = `<p class="error-text">Error: ${data.message}</p>`;
                resetButton();
              }
            } catch (e) {
              console.error('Failed to parse SSE:', e);
            }
          }
        }
      }
    } catch (err) {
      progressStatus.textContent = 'Failed';
      resultDiv.innerHTML = `<p class="error-text">Request failed: ${err.message}</p>`;
      resetButton();
    }
  });

  // Stop All Scripts (session-aware)
  document.getElementById('stopAllScriptsBtn').addEventListener('click', async () => {
    const stopResultDiv = document.getElementById('stopScriptsResult');
    stopResultDiv.style.display = 'block';

    // V√©rifier qu'une session est s√©lectionn√©e
    if (!currentPath) {
      stopResultDiv.textContent = 'Error: No session selected. Please upload or select a session first.';
      showToast('No session selected', 'warning');
      return;
    }

    stopResultDiv.textContent = 'Stopping scripts for this session...';
    try {
      const formData = new FormData();
      formData.append('session', currentPath);
      const res = await fetch('/stop_all_scripts', { method: 'POST', body: formData });
      const json = await res.json();
      if (res.ok) {
        const details = json.details || {};
        const stopped = details.total_stopped || 0;
        stopResultDiv.textContent = `${json.status} (${stopped} process(es) stopped)`;
        showToast('Scripts stopped', 'info');
      } else {
        stopResultDiv.textContent = `Error: ${json.error || res.statusText}`;
      }
    } catch (err) {
      stopResultDiv.textContent = 'Failed to stop: ' + err;
    }
  });
</script>
{% endblock %}
